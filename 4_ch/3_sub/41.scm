(define (distinct? items)
  (cond ((null? items) true)
		((null? (cdr items)) true)
		((member (car items) (cdr items)) false)
		(else (distinct? (cdr items)))))

(define (flatten x)
  (cond ((null? x) '())
		((pair? x) (append (flatten (car x)) (flatten (cdr x))))
		(else (list x))))

(define (multiple-dwelling)
  (define pos (list 1 2 3 4 5))
  (define (person iterate next . args)
	(if (null? iterate)
	  #f
	  (let ((result (next (flatten (append args (list (car iterate)))))))
		(if result
		  result
		  (person (cdr iterate) next args)))))

  (define (baker) 
	(person pos cooper)) 
  (define (cooper . args) 
	(person pos fletcher args))
  (define (fletcher . args)
	(person pos miller args))
  (define (miller . args) 
	(person pos smith args))
  (define (smith . args) 
	(person pos solution args))

  (define (solution . args)
	(let* ((floors (flatten args))
		   (baker (car floors))
		   (cooper (cadr floors))
		   (fletcher (caddr floors))
		   (miller (cadddr floors))
		   (smith (caddr (cddr floors))))
	  (cond ((= baker 5)  #f)
			((= cooper 1) #f)
			((= fletcher 5) #f)
			((= fletcher 1) #f)
			((= (abs (- fletcher cooper)) 1) #f)
			((< miller cooper) #f)
			((= (abs (- smith fletcher)) 1) #f)
			((not (distinct? (list baker cooper fletcher miller smith))) #f)
			(else (list (list 'baker baker)
						(list 'cooper cooper)
						(list 'fletcher fletcher)
						(list 'miller miller)
						(list 'smith smith))))))
  (baker))
(multiple-dwelling)
